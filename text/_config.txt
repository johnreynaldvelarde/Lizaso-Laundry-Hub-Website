size - "xs", "sm", "md", "lg", or "xl"


// Sample Size of Screen
<Box 
  sx={{ 
    p: { 
      xs: 1,   // 8px padding for extra-small screens (mobile)
      sm: 2,   // 16px padding for small screens (tablets)
      md: 3,   // 24px padding for medium screens (laptops)
      lg: 4,   // 32px padding for large screens (desktops)
      xl: 5    // 40px padding for extra-large screens (wider desktops)
    } 
  }}
>
  {/* Your content here */}
</Box>


React Native -> rnf / rnfce
React -> rafce

https://isomorphic-furyroad.vercel.app/roles-permissions


// FOR POST
export const handleAdminBasedSetNewUser = async (req, res, connection) => {
  const { id } = req.params;
  const { role_name, permissionsStatus } = req.body;

  try {
    await connection.beginTransaction();

    const query = `
     
    `;
    const [re] = await connection.execute(query, [id]);

    await connection.commit();
  } catch (error) {
    await connection.rollback();
  } finally {
    if (connection) connection.release();
  




 <Button
          variant="outlined"
          onClick={onClose}
          sx={{
            marginRight: 1,
            borderColor: COLORS.border2,
            borderRadius: "5px",
            fontWeight: 500,
            textTransform: "none",
            color: COLORS.text4,
            "&:hover": {
              borderColor: COLORS.border2,
              backgroundColor: COLORS.light,
            },
          }}
        >
          Cancel
        </Button>

        finally {
    if (connection) connection.release();
  }


  
// export const handlePostNewMessages = async (req, res, connection) => {
//   const { id } = req.params;
//   const { recieverId, text, senderType, receiverType } = req.body;

//   console.log(recieverId);
//   console.log(text);
//   console.log(senderType);
//   console.log(receiverType);

//   try {
//     await connection.beginTransaction();
//   } catch (error) {
//     await connection.rollback();
//     console.error("Error updating service request status:", error);
//     res.status(500).json({
//       success: false,
//       message: "An error occurred while updating the request.",
//     });
//   } finally {
//     connection.release();
//   }
// };

// export const handleGetStaffMessages = async (req, res, connection) => {
//   const { id } = req.params;

//   try {
//     // Begin the transaction
//     await connection.beginTransaction();

//     // SQL query to fetch messages based on the user's role (either customer or staff)
//     let query = `
//       SELECT
//         m.id,
//         m.message,
//         m.sender_type,
//         m.receiver_type,
//         m.isRead,
//         m.date_sent,
//         CASE
//           WHEN m.sender_customer_id IS NOT NULL THEN CONCAT(c.c_firstname, ' ', c.c_middlename, ' ', c.c_lastname)
//           WHEN m.sender_user_account_id IS NOT NULL THEN CONCAT(u.first_name, ' ', u.middle_name, ' ', u.last_name)
//         END AS sender_full_name,
//         CASE
//           WHEN m.recipient_customer_id IS NOT NULL THEN CONCAT(c2.c_firstname, ' ', c2.c_middlename, ' ', c2.c_lastname)
//           WHEN m.recipient_user_account_id IS NOT NULL THEN CONCAT(u2.first_name, ' ', u2.middle_name, ' ', u2.last_name)
//         END AS recipient_full_name
//       FROM Message m
//       LEFT JOIN Customer c ON m.sender_customer_id = c.id
//       LEFT JOIN User_Account u ON m.sender_user_account_id = u.id
//       LEFT JOIN Customer c2 ON m.recipient_customer_id = c2.id
//       LEFT JOIN User_Account u2 ON m.recipient_user_account_id = u2.id
//       WHERE (m.sender_customer_id = ? OR m.sender_user_account_id = ? OR m.recipient_customer_id = ? OR m.recipient_user_account_id = ?)
//     `;

//     // Execute the query, passing 'id' for both customer and staff (user) fields
//     const [rows] = await connection.execute(query, [id, id, id, id]);

//     // Commit the transaction
//     await connection.commit();

//     // Send the list of messages as a response
//     res.status(200).json({
//       success: true,
//       data: rows,
//     });
//   } catch (error) {
//     await connection.rollback();
//     console.error("Error fetching messages:", error);
//     res.status(500).json({
//       success: false,
//       message: "An error occurred while fetching the messages.",
//     });
//   } finally {
//     connection.release();
//   }
// };

// export const handleGetMessages = async (req, res, connection) => {
//   const { id } = req.params; // assuming this is either sender's user/customer id

//   try {
//     await connection.beginTransaction();
//     // Determine sender and receiver based on type
//     let senderCustomerId = null;
//     let senderUserAccountId = null;
//     let recipientCustomerId = null;
//     let recipientUserAccountId = null;
//     if (senderType === "Customer") {
//       senderCustomerId = id; // If the sender is a customer
//     } else if (senderType === "Staff") {
//       senderUserAccountId = id; // If the sender is a staff member
//     }
//     if (receiverType === "Customer") {
//       recipientCustomerId = receiverId; // If the receiver is a customer
//     } else if (receiverType === "Staff") {
//       recipientUserAccountId = receiverId; // If the receiver is a staff member
//     }
//     // Insert new message into the Message table using execute
//     const query = `
//       INSERT INTO Message
//       (sender_customer_id, sender_user_account_id, recipient_customer_id, recipient_user_account_id, message, sender_type, receiver_type, isRead, date_sent)
//       VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())
//     `;
//     await connection.execute(query, [
//       senderCustomerId,
//       senderUserAccountId,
//       recipientCustomerId,
//       recipientUserAccountId,
//       text,
//       senderType,
//       receiverType,
//       false, // isRead is false by default
//     ]);
//     await connection.commit();
//     res.status(200).json({
//       success: true,
//       message: "Message sent successfully!",
//     });
//   } catch (error) {
//     await connection.rollback();
//     console.error("Error sending message:", error);
//     res.status(500).json({
//       success: false,
//       message: "An error occurred while sending the message.",
//     });
//   } finally {
//     connection.release();
//   }
// };

// TRACK ORDER
export const handleGetCustomerTrackOrderAndProgress = async (
  req,
  res,
  connection
) => {
  const { id } = req.params; // customer id

  try {
    await connection.beginTransaction();

    // SQL query to get service requests along with progress
    const query = `
      SELECT 
        sr.id AS service_request_id,
        sr.store_id,
        IF(sr.user_id IS NULL, false, sr.user_id) AS user_id,
        sr.customer_id,
        sr.tracking_code,
        sr.customer_fullname,
        sr.customer_type,
        sr.notes,
        COALESCE(ua.username, 'Waiting') AS username,
        sr.request_date,
        COALESCE(sr.pickup_date, 'Waiting') AS pickup_date,
        COALESCE(sr.delivery_date, 'Waiting') AS delivery_date,
        sr.request_status,
        sr.qr_code,
        sr.qr_code_generated,
        sr.isPickup,
        sr.isDelivery,
        sp.id AS progress_id,
        sp.stage,
        sp.description,
        sp.completed,
        sp.false_description,
        sp.status_date,
        st.service_name,
        st.default_price
      FROM 
        Service_Request sr
      LEFT JOIN 
        Service_Progress sp ON sr.id = sp.service_request_id
      LEFT JOIN 
        User_Account ua ON sr.user_id = ua.id
      LEFT JOIN 
        Service_Type st ON sr.service_type_id = st.id
      WHERE 
        sr.customer_id = ? 
        AND sr.request_status != 'Canceled'
      ORDER BY 
        sr.request_date DESC;
    `;

    const [rows] = await connection.execute(query, [id]);

    // Structure the response data
    const result = rows.reduce((acc, row) => {
      // Check if the service request already exists in the accumulator
      let serviceRequest = acc.find(
        (req) => req.service_request.id === row.service_request_id
      );

      // If it doesn't exist, create a new entry
      if (!serviceRequest) {
        serviceRequest = {
          service_request: {
            id: row.service_request_id,
            store_id: row.store_id,
            user_id: row.user_id,
            user_name: row.username,
            customer_id: row.customer_id,
            service_type_id: row.service_type_id,
            service_name: row.service_name,
            service_default_price: row.default_price,
            tracking_code: row.tracking_code,
            customer_fullname: row.customer_fullname,
            customer_type: row.customer_type,
            notes: row.notes,
            request_date: row.request_date,
            pickup_date: row.pickup_date,
            delivery_date: row.delivery_date,
            request_status: row.request_status,
            qr_code: row.qr_code,
            qr_code_generated: row.qr_code_generated,
            isPickup: row.isPickup,
            isDelivery: row.isDelivery,
          },
          progress: [], // Initialize the progress array
        };
        acc.push(serviceRequest);
      }

      // Add the progress information for this service request
      serviceRequest.progress.push({
        id: row.progress_id,
        stage: row.stage,
        description: row.description,
        completed: row.completed,
        status_date: row.status_date,
        false_description: row.false_description,
      });

      return acc;
    }, []);

    result.forEach((serviceRequest) => {
      serviceRequest.progress.sort((a, b) => a.id - b.id);
    });

    await connection.commit();

    res.status(200).json({
      success: true,
      data: result,
    });
  } catch (error) {
    await connection.rollback();
    console.error("Error customer track order and progress:", error);
    res.status(500).json({
      success: false,
      message: "An error occurred while fetching data.",
    });
  } finally {
    if (connection) connection.release();
  }
};
