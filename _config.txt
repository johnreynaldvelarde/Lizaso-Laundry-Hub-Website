size - "xs", "sm", "md", "lg", or "xl"


// Sample Size of Screen
<Box 
  sx={{ 
    p: { 
      xs: 1,   // 8px padding for extra-small screens (mobile)
      sm: 2,   // 16px padding for small screens (tablets)
      md: 3,   // 24px padding for medium screens (laptops)
      lg: 4,   // 32px padding for large screens (desktops)
      xl: 5    // 40px padding for extra-large screens (wider desktops)
    } 
  }}
>
  {/* Your content here */}
</Box>


React Native -> rnf / rnfce
React -> rafce

https://isomorphic-furyroad.vercel.app/roles-permissions


// FOR POST
export const handleAdminBasedSetNewUser = async (req, res, connection) => {
  const { id } = req.params;
  const { role_name, permissionsStatus } = req.body;

  try {
    await connection.beginTransaction();

    const query = `
     
    `;
    const [re] = await connection.execute(query, [id]);

    await connection.commit();
  } catch (error) {
    await connection.rollback();
  } finally {
    if (connection) connection.release();
  




 <Button
          variant="outlined"
          onClick={onClose}
          sx={{
            marginRight: 1,
            borderColor: COLORS.border2,
            borderRadius: "5px",
            fontWeight: 500,
            textTransform: "none",
            color: COLORS.text4,
            "&:hover": {
              borderColor: COLORS.border2,
              backgroundColor: COLORS.light,
            },
          }}
        >
          Cancel
        </Button>

        finally {
    if (connection) connection.release();
  }


  
// export const handlePostNewMessages = async (req, res, connection) => {
//   const { id } = req.params;
//   const { recieverId, text, senderType, receiverType } = req.body;

//   console.log(recieverId);
//   console.log(text);
//   console.log(senderType);
//   console.log(receiverType);

//   try {
//     await connection.beginTransaction();
//   } catch (error) {
//     await connection.rollback();
//     console.error("Error updating service request status:", error);
//     res.status(500).json({
//       success: false,
//       message: "An error occurred while updating the request.",
//     });
//   } finally {
//     connection.release();
//   }
// };

// export const handleGetStaffMessages = async (req, res, connection) => {
//   const { id } = req.params;

//   try {
//     // Begin the transaction
//     await connection.beginTransaction();

//     // SQL query to fetch messages based on the user's role (either customer or staff)
//     let query = `
//       SELECT
//         m.id,
//         m.message,
//         m.sender_type,
//         m.receiver_type,
//         m.isRead,
//         m.date_sent,
//         CASE
//           WHEN m.sender_customer_id IS NOT NULL THEN CONCAT(c.c_firstname, ' ', c.c_middlename, ' ', c.c_lastname)
//           WHEN m.sender_user_account_id IS NOT NULL THEN CONCAT(u.first_name, ' ', u.middle_name, ' ', u.last_name)
//         END AS sender_full_name,
//         CASE
//           WHEN m.recipient_customer_id IS NOT NULL THEN CONCAT(c2.c_firstname, ' ', c2.c_middlename, ' ', c2.c_lastname)
//           WHEN m.recipient_user_account_id IS NOT NULL THEN CONCAT(u2.first_name, ' ', u2.middle_name, ' ', u2.last_name)
//         END AS recipient_full_name
//       FROM Message m
//       LEFT JOIN Customer c ON m.sender_customer_id = c.id
//       LEFT JOIN User_Account u ON m.sender_user_account_id = u.id
//       LEFT JOIN Customer c2 ON m.recipient_customer_id = c2.id
//       LEFT JOIN User_Account u2 ON m.recipient_user_account_id = u2.id
//       WHERE (m.sender_customer_id = ? OR m.sender_user_account_id = ? OR m.recipient_customer_id = ? OR m.recipient_user_account_id = ?)
//     `;

//     // Execute the query, passing 'id' for both customer and staff (user) fields
//     const [rows] = await connection.execute(query, [id, id, id, id]);

//     // Commit the transaction
//     await connection.commit();

//     // Send the list of messages as a response
//     res.status(200).json({
//       success: true,
//       data: rows,
//     });
//   } catch (error) {
//     await connection.rollback();
//     console.error("Error fetching messages:", error);
//     res.status(500).json({
//       success: false,
//       message: "An error occurred while fetching the messages.",
//     });
//   } finally {
//     connection.release();
//   }
// };

// export const handleGetMessages = async (req, res, connection) => {
//   const { id } = req.params; // assuming this is either sender's user/customer id

//   try {
//     await connection.beginTransaction();
//     // Determine sender and receiver based on type
//     let senderCustomerId = null;
//     let senderUserAccountId = null;
//     let recipientCustomerId = null;
//     let recipientUserAccountId = null;
//     if (senderType === "Customer") {
//       senderCustomerId = id; // If the sender is a customer
//     } else if (senderType === "Staff") {
//       senderUserAccountId = id; // If the sender is a staff member
//     }
//     if (receiverType === "Customer") {
//       recipientCustomerId = receiverId; // If the receiver is a customer
//     } else if (receiverType === "Staff") {
//       recipientUserAccountId = receiverId; // If the receiver is a staff member
//     }
//     // Insert new message into the Message table using execute
//     const query = `
//       INSERT INTO Message
//       (sender_customer_id, sender_user_account_id, recipient_customer_id, recipient_user_account_id, message, sender_type, receiver_type, isRead, date_sent)
//       VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW())
//     `;
//     await connection.execute(query, [
//       senderCustomerId,
//       senderUserAccountId,
//       recipientCustomerId,
//       recipientUserAccountId,
//       text,
//       senderType,
//       receiverType,
//       false, // isRead is false by default
//     ]);
//     await connection.commit();
//     res.status(200).json({
//       success: true,
//       message: "Message sent successfully!",
//     });
//   } catch (error) {
//     await connection.rollback();
//     console.error("Error sending message:", error);
//     res.status(500).json({
//       success: false,
//       message: "An error occurred while sending the message.",
//     });
//   } finally {
//     connection.release();
//   }
// };
